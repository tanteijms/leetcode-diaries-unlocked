# [207. 课程表](https://leetcode.cn/problems/course-schedule/)



## 题目

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

 

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**



## points

1. 重点在于，我们这个先修课程，是否能够满足一个接着另一个修，而不出现顺序混乱

2. 转化为用图去做，判断图中是否有环。可以在dfs的过程中，判断下一个结点是否是正在访问中，如果是，那就是环，于是不满足要求

3. 我们用三个状态来度量，0未访问，1正在访问，也就是当前dfs进行时的，2已访问完毕。2的时候再与其他的课程产生先修关系，是可以满足的，只是不能出现环，也就是无限循环

4. 由于题目给的是二维数组，且内层数组长度都是2，[a,b]表示必须先修b，才能修a。因此在图中，表示先后顺序，就写成b->a。先遍历这个表示先修关系的数组，把它转化为图

5. 对于所有的课程，创建一个数组，用0 1 2来表示它现在的状态。初始化全为0

6. 遍历这个数组，若为0，则从他开始递归，深度优先

7. 在dfs的过程中：

   遍历到某个课，就标记为1，说明它正在此时dfs访问中

   遍历它的邻居，若下一个课为1，就找到了环，直接返回true

   若下层返回true，则也直接返回

   如果从当前的课开始dfs，没有找到环，就标记为2，表示它在此层dfs访问完毕了，就返回true

8. 对于课程数组的dfs过程中，任意一个返回true，则表示不能完成课程，于是整个函数返回false；否则返回true

9. 如果出现交叉的情况，如0-1-2  3-1-4，那么在从3到1的时候，会发现1是2，说明从1出发一定不存在环，就直接结束了，不dfs。4其实是和3分开dfs遍历的，因为在1的时候，会遍历g图里1的所有邻居，因此实际上4是和2一起dfs递归的
