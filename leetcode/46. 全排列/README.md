# [46. 全排列](https://leetcode.cn/problems/permutations/)



##  题目

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

 

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**



## points

1. 回溯

2. 元素不相同，全排列个数等于n!

3. 回溯三问：当前操作？子问题？下一个子问题？

4. 想象一棵树，根节点是空的，从下面的节点开始穷举，得到所有的结果

   因此可以对于每一个不同的路径，都进行统计。至于当前应该选什么数，由于是不重复的，因此用一个set来存当前的剩余的数，并且在选中了某个数以后就把他删除掉，然后再进行下一层的寻路

   对于每一层的，都需要维护一个set。如果传引用的话，在erase的时候，会出现迭代器失效的错误，导致内外层没有办法实现统一，会出错。因此内存上是十分爆炸的

   维护一个ans，再维护一个path，这个path用来记录每一条分支上的所有数的序列，是临时的，每条路径上各不相同。

   在dfs深度优先遍历的时候，首先判断当前应该填入path的哪一个位置，即i，若已经==n，则已经形成了一个答案。

   若还没有填满整个path，则遍历剩余的set，对于剩余的每一个元素，都会存在一条新的路径，我们从当前的set把这个当前元素剔除以后，传给后面的继续寻找。

   在主函数里，通过vector的nums构造一个set的s，然后从i=0开始dfs，每一趟找到完整的路径，最后都记录一个ans值。

5. 回溯vs递归

   递归是将大问题分解为小问题的方法

   回溯=递归+状态恢复+剪枝优化。回溯是一种算法策略，通过试错来寻找解决方法。如果发现当前的路径不可行，就退回到上一步，这个时候需要恢复现场，因为是回到上一步再找新的方法，因此前一个失败的方法的痕迹需要清除掉

   回溯是为了探索全部的解空间



## 解2

1. 解1在每次传递的时候都要拷贝一份set，可以改为维护一个布尔数组，类似is_visited，每次判断当前元素值是否使用过了。
2. 注意在每次寻找路径的时候，回溯回来以后，需要恢复现场，也就是传下去的时候更改的true，要改为未访问，false