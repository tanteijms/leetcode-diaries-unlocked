# [51. N 皇后](https://leetcode.cn/problems/n-queens/)



## 题目

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

![img](./assets/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

 

**提示：**

- `1 <= n <= 9`



## points

1. 不用对整个棋盘广度优先遍历，因为每一行一定只有一个，所以直接按行放置即可

2. 枚举0~n-1的全排列。但是还有一个斜线的规则

   可以从上往下，然后用函数y=x+b  y=-x+b这样的直线来判断是否在斜线上，这样的话，可以和坐标联系起来，方便直接进行判断

3. 复盘

   定义ans

   定义n的镜像nn

   定义棋盘，path，是ans的每个内容

   定义辅助函数legal，传入的是当前格子，也就是对应的row和col

   首先判断列是否合法。从第0行开始遍历，如果某行的当前col列有Q，则false

   然后判断斜线，首先是斜右上方的。这里采用了从当前格子的右上角开始，然后一步步向右上移动的策略，不用考虑复杂的row和col的关系。每次只需要i--,j++

   接着斜左上方的斜线，也是从当前格子的左上角开始，一步步向左上移动。每次i--,j--

   定义dfs，传入i即可，既是当前判断的行，也是放置皇后的个数

   若当前i已经==n，则直接加上答案，返回

   然后对于当前行，我们每一列都有可能可以进行放置，因此遍历所有列，每个格子进行判断是否可以放置，用legal，如果可以放的话，就给当前格子写为Q，然后递归下一层。记得恢复现场

   本题注意的一点是对于棋盘的类型的选用，可以直接string，因为C++可以像vector<char\>一样进行索引的访问