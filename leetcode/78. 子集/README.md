# [78. 子集](https://leetcode.cn/problems/subsets/)



## 题目

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**



## points

1. 回溯

   特点：增量构造答案，递归实现

   写对边界与非边界条件，相信数学归纳法

2. 回溯三问：

   当前操作？

   子问题？

   下一个子问题？

3. 子集型回溯。0-1背包问题也是一种子集型回溯

   子集：看每个元素，选或者不选

   从输入考虑，最终叶子是答案，因为是在递归的过程中，决定是否选择

   到每一步的当前操作就是，选或者不选

   选的话，注意恢复现场

4. python，列表对象，在加入到ans的时候，是把同一个列表的引用都丢进到ans里。当path指向的对象改变时，ans答案里的也跟着变化了

   而若C++，添加的时候添加的是值，就是vector的默认语义，而不是引用，因此就是copy

5. 复盘：

   此题考虑回溯，因为子集可以从每个元素是否选择进行考虑。对于递归到的每一个i，表示nums的i号元素。每次考虑选或不选。如果不选，就直接递归dfs(i+1)。若选，就先加入path，然后i+1，然后记得pop掉，恢复现场。然后我们从0开始回溯即可。如果i已经到了n的大小，那么就开始往回走。这样能够从每个元素对应选or不选，找到各种不同的路径答案



## 解2

1. 若从答案的角度考虑，从每一种可能的答案，path，考虑每一位分别选谁

   因为集合不考虑顺序，我们可以规定顺序来考虑

   规定严格递增，枚举的数字大于上一个数字。

   注意i指的是当前考虑答案的哪一位

   当前操作，从i，>=i的范围里选数字，并加入path

   子问题，从>=i的数字中构造子集

   下一个子问题，从>=j+1的数字中构造子集

2. 复盘：从答案path的情况出发，看每个位置上，选哪个元素。集合是无所谓顺序的，但可以规定就对nums的元素从0号元素开始递增选择数。对于一条path上的每一个位置，从0开始，我们可以选nums的0号元素，也可以直接选>0的某个j。然后这样的话，后面的子问题就是从>j的某个数里选出来，然后加入到path。这样每次加入的元素可以是跳跃的，因此就会导致最终为空or为原集合。

   落实到dfs上，对于每个i位置上的坑，首先我们可以直接把到目前位置的这个路径加入进去，因为这代表从i+1以后的全部都不选，这当然是一种子集结果。然后就是从i开始，对于以后的每一个元素，考虑是否填入当前path的坑位里。如果j=i直接加入了，那这就是连续的（当然也可以不连续）。而我们在遍历的时候，当然也有后面的某次遍历，他是直接跳过了从i到j-1的所有的数，直接加了最后的，这就是不连续的一种。这样的话，对于每一个坑位，都会选择一个nums的元素（如果没选的话，就是直接一开始的添加到ans）。所以每次都要dfs(j+1)后恢复现场
