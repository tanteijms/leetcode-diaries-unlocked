class Solution
{
public:
    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)
    {
        if (nums1.size() > nums2.size())
            swap(nums1, nums2);
        // 令a是小的，这样二分范围更小，更快，更方便

        int m = nums1.size(), n = nums2.size();
        int le = 0, ri = m - 1;
        while (le <= ri)
        {
            int i = le + (ri - le) / 2;
            // 我们对a进行二分，i的值由当前二分查到的范围确定，也就是一般的mid
            // int j = (m + n + 1) / 2 - i - 2;
            // 这个式子：
            // m+n+1是为了确保左边数大于等于右边；
            // -i-2，实际上本来是-(i+1)-1
            // i+1是上面a 从i的后面分割，那么a的左半就占了i+1个
            // 再-1，是因为数组下标从0开始
            // 还是写成分布的吧，看的清除点
            int j = (m + n + 1) / 2 - (i + 1) - 1;

            // 注意二分缩小范围的核心，就是比较当前分割线两边的。
            // i的后面，是a的分割线；j的后面，是b的分割线

            // j+1就是b的右边，最小的那个。要保证a的左边最大的那个，小于b的右边最小的那个，才是好的划分
            if (nums1[i] <= nums2[j + 1])
                le = i + 1;
            else
                ri = i - 1;

            // 只需要对a进行二分就可以了
            // 当最终a的分割线确定的时候，显然b的分割线也确定
            // 那么由这样的划分一定是唯一的，可以推得b的分割线就是所求，不必校验
            // 也就是说 i j一定满足 a[i]<=b[j+1]  b[j]<=a[i+1]，可以相等
        }

        // 考虑退出循环前一刻：le=ri=i
        // 如果此时a的i小于等于b的j+1，则le会右移，这导致出了边界。
        // 而若a的i大于b的j+1，ri左移，就会回到a的更小的那一边
        // 所以，答案就是ri
        // 或者考虑循环的不变量：
        // a[left-1] <= b[j+1]
        // a[right+1] > b[j+1]
        // 因为答案一定在[le, ri]内，le很小，一定满足小于分割点；ri过于大，会超出
        // 从最初始的看，le是0，ri是m。而在二分的过程里，我们会让le不断变大，ri不断变小
        int i = ri;
        int j = (m + n + 1) / 2 - (i + 1) - 1;

        // 根据i j这两个分割点，取出a b左边的最小 和 右边的最大
        int ai = i >= 0 ? nums1[i] : INT_MIN; // 如果a整体都非常大，都划分在右边，那么就认为a的左边是无穷小。
        // 这样在比较的时候，会自然取b的左边为整体分割线，左边的最大。
        // 因为没有a的元素，所以不参与考虑
        int bj = j >= 0 ? nums2[j] : INT_MIN; // 这个也是参与比较左边的max，因此用无穷小

        int ai1 = i + 1 < m ? nums1[i + 1] : INT_MAX; // 因为分割线在i的后面，因此i+1开始才是右边的
        // 同理，这个是参与比较右边的最小的，因此用无穷大，不影响判断
        int bj1 = j + 1 < n ? nums2[j + 1] : INT_MAX;
        // 以上四个，其实就是看这四个数是否还满足在a b的范围内
        // 如果出现某一个数组特别小，或特别大，就导致不在范围内。其实就是范围检查

        int max1 = max(ai, bj);
        int min2 = min(ai1, bj1);

        return (m + n) % 2 ? max1 : (max1 + min2) / 2.0;
        // 如果为1，说明不整除，总共奇数个
    }
};