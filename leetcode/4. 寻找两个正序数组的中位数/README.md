# [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)



## 题目

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

 

 

**提示：**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- $-10^6 <= nums1[i], nums2[i] <= 10^6$



## 题解

```cpp
class Solution
{
public:
    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)
    {
        if (nums1.size() > nums2.size())
            swap(nums1, nums2);
        // 令a是小的，这样二分范围更小，更快，更方便

        int m = nums1.size(), n = nums2.size();
        int le = 0, ri = m - 1;
        while (le <= ri)
        {
            int i = le + (ri - le) / 2;
            // 我们对a进行二分，i的值由当前二分查到的范围确定，也就是一般的mid
            // int j = (m + n + 1) / 2 - i - 2;
            // 这个式子：
            // m+n+1是为了确保左边数大于等于右边；
            // -i-2，实际上本来是-(i+1)-1
            // i+1是上面a 从i的后面分割，那么a的左半就占了i+1个
            // 再-1，是因为数组下标从0开始
            // 还是写成分布的吧，看的清除点
            int j = (m + n + 1) / 2 - (i + 1) - 1;

            // 注意二分缩小范围的核心，就是比较当前分割线两边的。
            // i的后面，是a的分割线；j的后面，是b的分割线

            // j+1就是b的右边，最小的那个。要保证a的左边最大的那个，小于b的右边最小的那个，才是好的划分
            if (nums1[i] <= nums2[j + 1])
                le = i + 1;
            else
                ri = i - 1;

            // 只需要对a进行二分就可以了
            // 当最终a的分割线确定的时候，显然b的分割线也确定
            // 那么由这样的划分一定是唯一的，可以推得b的分割线就是所求，不必校验
            // 也就是说 i j一定满足 a[i]<=b[j+1]  b[j]<=a[i+1]，可以相等
        }

        // 考虑退出循环前一刻：le=ri=i
        // 如果此时a的i小于等于b的j+1，则le会右移，这导致出了边界。
        // 而若a的i大于b的j+1，le左移，就会回到a的更小的那一边
        // 所以，答案就是ri
        // 或者考虑循环的不变量：
        // a[left-1] <= b[j+1]
        // a[right+1] > b[j+1]
        // 因为答案一定在[le, ri]内，le很小，一定满足小于分割点；ri过于大，会超出
        // 从最初始的看，le是0，ri是m。而在二分的过程里，我们会让le不断变大，ri不断变小
        int i = ri;
        int j = (m + n + 1) / 2 - (i + 1) - 1;

        // 根据i j这两个分割点，取出a b左边的最小 和 右边的最大
        int ai = i >= 0 ? nums1[i] : INT_MIN; // 如果a整体都非常大，都划分在右边，那么就认为a的左边是无穷小。
        // 这样在比较的时候，会自然取b的左边为整体分割线，左边的最大。
        // 因为没有a的元素，所以不参与考虑
        int bj = j >= 0 ? nums2[j] : INT_MIN; // 这个也是参与比较左边的max，因此用无穷小

        int ai1 = i + 1 < m ? nums1[i + 1] : INT_MAX; // 因为分割线在i的后面，因此i+1开始才是右边的
        // 同理，这个是参与比较右边的最小的，因此用无穷大，不影响判断
        int bj1 = j + 1 < n ? nums2[j + 1] : INT_MAX;
        // 以上四个，其实就是看这四个数是否还满足在a b的范围内
        // 如果出现某一个数组特别小，或特别大，就导致不在范围内。其实就是范围检查

        int max1 = max(ai, bj);
        int min2 = min(ai1, bj1);

        return (m + n) % 2 ? max1 : (max1 + min2) / 2.0;
        // 如果为1，说明不整除，总共奇数个
    }
};
```



## points

1. 中位数：讲数值集合划分为大小相等的两部分。考虑讲两个数组均匀分组，数组2的每一个数都大于数组1，划分开

2. 考虑每次二分来减少数组个数。比如一开始，我们要找的是两个数组中第k小的数，k=(m+2)/2 向下取整。一开始我们先分别看a[k/2-1] b[k/2-1]（注意数组这里下标需要-1）。这样的情况下，如果a的比b的小，那么说明a[k/2-1]及以前的，一定都不是中位数，可以舍去。反之则舍去b前边的，同理。

3. 我们是要对a b两个数组进行分割，找到他们两个当中的分割线，能够分成左右两份。ab本身是有序的，那么自然分割线左右两侧，左的数一定都小于右的数。我们在二分的过程中，要确保的事情是，让a左边的最大值，也就是分割线左边那个值，小于b右边的最小值，也就是分割线右边那个值；对于b左边的最大值，当然也要小于a右边的最小值，二者同理的。因此这就是二分不断缩小范围的条件。

   而且，只需要在a进行二分缩小范围就可以了，因为我们知道a b元素的总数，也就是m+n，只要找到a的分割线范围，b的分割线范围也是确定的。这里我们分割让左边元素个数大于等于右边，这样的话得到的索引值：如果元素总数是奇数，那么最终的分割线左边a b中更大的那个数，恰好就是中位数；如果元素总数是偶数，那么就用分割线，左边，a b更大的那个    和分割线，右边，a b更小的那个，加和并/2.0即可（题目要求返回值是double）。

4. 由3所述，此题的核心就是找到ab两数组的分割线，然后对分割线左右的数字进行判断，最终找到中位数

5. 复盘：

   首先我们确定对其中一个数组进行二分查找即可，所以对小的更好。如果a比b元素多，那就swap

   取m n，分别分nums1 nums2的大小

   开始对a数组进行二分查找，le=0,ri=m-1

   这里需要明确我们二分的目的：如果看普通的做法的话，就是把两个数组归并起来，然后按排好序的直接找到中位数。但这样的话不满足时间复杂度。我们考虑可以直接在两个数组上进行操作，找到第k小的数，k=(m+n)/2向下取整。由于a b本身都是有序的，那么可以对a b进行分割，这样分割得到左半部分的a和b，其个数恰好是(m+n+1)/2，这里取左半部分≥右半部分，目的是如果是总数为奇数的话，就可以直接当前下标就是要的答案值。若是偶数，那么久左右两部分数量相等，那么计算当前下标和当前下标+1的平均值即可

   为了得到a b两个数组的分割线，我们可以设a的分割线为i后面，也就是i及i以前的，认为是左半部分。而这样可以利用总数的限定得到：b的分割线j=(m+n+1)/2 - (i+1) - 1。也就是总共能有的一半元素个数，减掉i已经有了的。注意-(i+1) - 1，这是为了对齐数组下标从0开始。那么这样的话，我们可以得到a的左半部分和b的右半部分，分别是a[i]以及b[j+1]。因为a b本身是有序的，所以a b内部左右两部分不需要比较。我们只需要确保a左半的最大 小于 b右半的最小，这样说明最终找到了这个i，是a的分割线。

   为什么不用找b的呢？因为a b元素总数是确定的，当我们找到i的时候，j也就唯一确定了，此时的j也必然满足b左半的最大 小于 a右半的最小。偷个懒，不用算了

   这样我们就确定了二分的范围，以及二分的条件。只需要对a进行二分查找操作即可

   由于采用闭区间，下面考虑最终le=ri=i的时候。这个时候代入循环：

   如果此时a的i小于等于b的j+1，则le会右移，这导致出了边界。ri仍然是满足小于b右半的那个i

   而若a的i大于b的j+1，ri左移，就会回到a的更小的那一边。ri仍然是满足小于b右半的那个i

   所以，答案就是ri

   下面有了确定的i和j，我们取出来分割线左右的四个值。但这里需要考虑极端情况，即a的最大比b的最小还要小，那么此时a的分割线就会看作是m-1后面，也就是没有；当然也有b的最大比a的最小还要小。

   我们简化考虑。我们现在知道i j是分割线的左边，i+1 j+1是分割线的右边，下面要取出来啊这四个数，那么也就是要确保他们的范围。

   对于i j，因为是左边的，所以有可能到了0的左边，这样的话，因为最后我们是要i j里更大的那一个，就恰好是中位数那条线上的。所以为了不影响最终的结果，如果i j<0，那么就取ai bj为无穷小

   对于i+1 j+1，因为是左右边的，所以有可能到了最后的右边，这样的话，因为最后我们是要i+1 j+1里更小的那一个，就恰好是中位数那条线右边的的。所以为了不影响最终的结果，如果i+1 j+1超出了各自数组的范围，那么就取ai1 bj1为无穷大

   最终根据m+n总数的奇偶，分别来算。若奇，答案就是ai bj更大的那个；若偶，就和ai1 bj1更小的那个求个平均。

   注意返回值为double，那么求平均的时候/2.0就可以满足不被截断