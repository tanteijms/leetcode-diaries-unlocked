# [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)



## 题目

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

 

**示例 1：**

**![img](./assets/oranges.png)**

```
输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

**示例 2：**

```
输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。
```

**示例 3：**

```
输入：grid = [[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 10`
- `grid[i][j]` 仅为 `0`、`1` 或 `2`



## 题解

```cpp
class Solution
{
    int DIRECTIONS[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 四方向

public:
    int orangesRotting(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        int fresh = 0;
        vector<pair<int, int>> q; // 统计腐烂的，模拟每一分钟
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (grid[i][j] == 1)
                    fresh++;
                else if (grid[i][j] == 2)
                    q.emplace_back(i, j);
            }
        }

        int ans = 0;
        while (fresh && !q.empty())
        {
            ans++;
            vector<pair<int, int>> nxt; // 当前时间下一次会腐烂的
            for (auto &[x, y] : q)
            {
                for (auto d : DIRECTIONS)
                {
                    int i = x + d[0], j = y + d[1];
                    if (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1)
                    {
                        fresh--;
                        grid[i][j] = 2;
                        nxt.emplace_back(i, j);
                    }
                }
            }
            q = move(nxt);
        }
        return fresh ? -1 : ans;
    }
};
```





## points

1. 这题和数多少个岛屿的区别是，每一份中腐烂的桔子都会变多，如果每个区域的桔子分别分开去计算最大时间，会很麻烦

2. 因此不用深度优先，而考虑广度优先，每分钟考虑当前腐烂区域下一次会延申到的新的区域，然后切换下一分钟。用计数来模拟实际的时间流动

3. 首先定义一个全局的方向数组，因为一个点的腐烂是向四面八方同时扩散的，因此考虑下一分钟，就要对四个方向的都进行考虑

4. 对于主函数体。全局维护一个fresh，用来计算当前时间下，剩余的新鲜的个数。

   维护一个队列，就像二叉树的层序遍历一样，是当前需要遍历的腐烂的点

   首先初始化，遍历整个图的所有点，对于所有1的，给fresh++；对于为2的，加入到初始的q腐烂队列里

   初始化答案为0

   下面进入模拟时间的循环，循环终止条件为，q为空，即没有新的未考虑到的腐烂的了，或已经没有新鲜的了，最后恰好所有的都腐烂，且最新腐烂了最后一批。

   首先给ans++，模拟当前时间+1.

   维护一个和q一样的nxt，用来更新下一时间的q

   遍历q里所有的点，是数对，所以用auto &[x,y]，但其实并不需要修改，只是直接用引用的话，避免了每次都拷贝一份，防止大量数据的时候的额外空间开销。

   对于每一个点，广度优先，因此四个放下都要考虑，看看他是否在下一秒会腐烂

   遍历四个方向的时候，若下一个点在图的范围内，且为新鲜的，就给fresh--，并且把当前新鲜改为腐烂，并加入到nxt里，用于下一次遍历的时候更新q

   注意我们在一开始就给时间+1了，所以目前查找的就是+1时间后的，也就是开始以后的，因此是对的。

   当前轮次更新以后，用move把nxt赋给q

5. 最后根据fresh来判断。因为循环退出，要么是腐烂的都已经尽可能地使自己周围的都腐烂了，要么是直接没有新鲜的了。因此如果当前还有新鲜的，说明是不会被腐烂的，就返回-1。否则返回ans